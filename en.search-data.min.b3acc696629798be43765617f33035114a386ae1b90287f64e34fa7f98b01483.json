[{"id":0,"href":"/SE-Labs/docs/else/res/httprequest/","title":"HTTP 八大请求","section":"相关资料","content":"HTTP 八大请求 #  "},{"id":1,"href":"/SE-Labs/docs/else/works/","title":"往届作品","section":"Else","content":"往届作品 #  学习之余也可以点个 Star ~~   问卷星球 - 黄泽桓团队小学期作品（全组满分项目） 问卷星球 - 周勤团队小学期作品 史莱姆学术分享平台 - 史莱姆团队软工二项目  "},{"id":2,"href":"/SE-Labs/docs/else/ref/","title":"参考文献","section":"Else","content":"参考文献 #   Git 教程 - RUNOOB.COM Git - 管理项目和控制版本的工具 HTTP 的八大请求方式  "},{"id":3,"href":"/SE-Labs/docs/labs/lab01/git/","title":"Git 简易教程","section":"Lab01 Git","content":"Git 指南 #  本教程涉及命令行指令说明时，[] 表示该参数为可选，\u0026lt;\u0026gt; 仅说明参数意义，需根据实际来定义  Git 简介 #  Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理或大或小的项目。利用 git，可以在本地很好地控制项目版本，让项目有条不紊地进行，编写代码错误还能通过回退进行纠正；通过提交、拉取、推送等操作，与队友或同事参与远程共同开发。\n分布式版本控制系统 在分布式版本控制系统中，系统保存的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是该控制系统是分布式的，开发者从中央服务器拷贝下来代码时，拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这样即使某一台机器宕机也能找到文件的完整备份。\n   Git 安装 #  Windows 安装包下载地址：https://gitforwindows.org/\n官网慢，可以用国内的镜像：https://npm.taobao.org/mirrors/git-for-windows/\n完成安装之后，就可以在 cmd 或 powershell 等命令行工具使用 git 工具了。一般情况下，在某个文件夹点击右键，你可以看到 Git Bash Here，通过这个也可以打开 Git 工具。\nMacOS 在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具。\n下载地址为：http://sourceforge.net/projects/git-osx-installer/\nLinux 尝试在终端输入 git，看看系统有没有安装；没有的话输入以下命令安装：\nsudo apt-get install git  Git 配置 #  Git 提供了一个叫做 git config 的工具，用于配置或读取相应的工作环境变量。这些环境变量决定了 Git 在各个环节的管理员信息和使用方式，存放于 /etc/gitconfig (所有用户生效 –system) 或 ~/.gitconfig (当前用户配置 –global)。\n需要设置一下用户信息才能使用 Git 提交 commit，在终端输入：\ngit config --global user.name \u0026#34;yourname\u0026#34; git config --global user.email \u0026#34;youremail\u0026#34; Git 基本流程 #  创建仓库 #  首先在 Github/Gitee 平台创建仓库 (New a repositry)，克隆到本地：\ngit clone \u0026lt;remote_url\u0026gt; [local_dir_name] 或者在本地初始化仓库，并添加远程仓库链接：\ngit init # 初始化仓库 git remote add origin \u0026lt;remote_url\u0026gt; # 添加远程仓库，并命名为 origin（默认） 如果采用 clone 的方式，一定要 cd 进入到克隆下来的文件夹里，才能执行后续 Git 操作  修改提交 #  git add \u0026lt;file_name\u0026gt; # 将指定文件加入暂存区 git add . # 或使用.将项目所有文件加入暂存区（除.gitignore指定的文件外） git commit -m \u0026#34;\u0026lt;message\u0026gt;\u0026#34; # 将暂存区内容打包成commit，提交到本地仓库 git push # 将本地仓库内容提交到远程仓库 这样就实现了一次修改的提交和推送。\n工作区、暂存区和本地仓库  工作区：即当前进行工作的文件目录，文件修改但未提交，处于已修改状态（modified） 暂存区：运行git add命令后文件保存的区域，也就是下次提交要保存的文件，文件处于已暂存状态（staged） 本地仓库：即版本库，记录了提交的完整状态和内容，该区域文件处于已提交状态（committed）     同步远程仓库 #  在多人合作开发的情况下，需要定期 pull 仓库保持进度同步：\ngit pull [\u0026lt;remote_name\u0026gt; \u0026lt;remote_branch\u0026gt;[:\u0026lt;local_branch\u0026gt;]] 分支工作 #  在项目开发中，常常会建立两个分支：\n master/main：存储生产环境，可部署版本 dev：存储开发环境  当然，在多人开发中，也可能会为每个人建立分支，大家在各自分支上完成自己的开发任务。\ngit branch -l # 查看所有分支 git checkout \u0026lt;branch_name\u0026gt; # 切换到指定分支 git checkout -b \u0026lt;branch_name\u0026gt; # 根据当前分支，新建一个分支并切换到该分支上 git merge [\u0026lt;branch1\u0026gt;] \u0026lt;branch2\u0026gt; # 将branch2合并到branch1，省略branch1参数时表示合并到当前分支 当合并分支出现冲突时，也就是两个人分别在各自分支上修改了同一处，Git 无法自动合并，则会报错冲突。此时需要手动修改冲突文件，可选择保留哪一分支的内容，之后再 add/commit/push。\n错误回退 #  Git 多工作区和版本库机制，允许你回头是岸。\n如果发现提交了错误文件：\n 若文件未添加至暂存区：使用 git checkout \u0026lt;filename\u0026gt; 将文件替换成暂存区版本，或 git checkout . 将工作区内的所有文件替换成暂存区内的文件（谨慎使用） 若文件已添加到暂存区但未提交到本地仓库：使用 git reset HEAD . 撤销暂存区的所有修改至工作区，接下来就回到了上一步 若已提交到本地仓库：使用 git reset --hard HRAD^ 将所有文件回退至上一版本  本文仅介绍 Git 工作流程，具体指令见 Git 指令全集  "},{"id":4,"href":"/SE-Labs/docs/labs/lab01/git_command/","title":"Git 指令全集","section":"Lab01 Git","content":"Git 指令全集 #  仓库 #  # 在当前目录新建一个Git代码库 $ git init  # 新建一个目录，将其初始化为Git代码库 $ git init \u0026lt;project-name\u0026gt;  # 下载一个项目和它的整个代码历史 $ git clone \u0026lt;url\u0026gt; 配置 #  # 显示当前的Git配置 $ git config --list  # 编辑Git配置文件 $ git config -e \u0026lt;--global\u0026gt;  # 设置提交代码时的用户信息 $ git config \u0026lt;--global\u0026gt; user.name \u0026#34;\u0026lt;name\u0026gt;\u0026#34; $ git config \u0026lt;--global\u0026gt; user.email \u0026#34;\u0026lt;email address\u0026gt;\u0026#34; 增加/删除文件 #  # 添加指定文件到暂存区 $ git add \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt; ...  # 添加指定目录到暂存区，包括子目录 $ git add \u0026lt;dir\u0026gt;  # 添加当前目录的所有文件到暂存区 $ git add .  # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p  # 删除工作区文件，并且将这次删除放入暂存区 $ git rm \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt; ...  # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached \u0026lt;file\u0026gt;  # 改名文件，并且将这个改名放入暂存区 $ git mv \u0026lt;file-original\u0026gt; \u0026lt;file-renamed\u0026gt; 代码提交 #  # 提交暂存区到仓库区 $ git commit -m \u0026lt;message\u0026gt;  # 提交暂存区的指定文件到仓库区 $ git commit \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt; ... -m \u0026lt;message\u0026gt;  # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a  # 提交时显示所有diff信息 $ git commit -v  # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m \u0026lt;message\u0026gt;  # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt; ... 分支 #  # 列出所有本地分支 $ git branch  # 列出所有远程分支 $ git branch -r  # 列出所有本地分支和远程分支 $ git branch -a  # 新建一个分支，但依然停留在当前分支 $ git branch \u0026lt;branch-name\u0026gt;  # 新建一个分支，并切换到该分支 $ git checkout -b \u0026lt;branch\u0026gt;  # 新建一个分支，与远程分支同步，并切换到该分支 $ git checkout -b \u0026lt;branch\u0026gt; \u0026lt;remote-branch\u0026gt;  # 新建一个分支，指向指定commit $ git branch \u0026lt;branch\u0026gt; \u0026lt;commit\u0026gt;  # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track \u0026lt;branch\u0026gt; \u0026lt;remote-branch\u0026gt;  # 切换到指定分支，并更新工作区 $ git checkout \u0026lt;branch-name\u0026gt;  # 切换到上一个分支 $ git checkout -  # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; \u0026lt;branch\u0026gt;  # 合并指定分支到当前分支 $ git merge \u0026lt;branch\u0026gt;  # 选择一个commit，合并进当前分支 $ git cherry-pick \u0026lt;commit\u0026gt;  # 删除分支 $ git branch -d \u0026lt;branch-name\u0026gt;  # 删除远程分支 $ git push origin --delete \u0026lt;branch-name\u0026gt; $ git branch -dr \u0026lt;remote/branch\u0026gt; 标签 #  # 列出所有tag $ git tag  # 新建一个tag在当前commit $ git tag \u0026lt;tag\u0026gt;  # 新建一个tag在指定commit $ git tag \u0026lt;tag\u0026gt; \u0026lt;commit\u0026gt;  # 删除本地tag $ git tag -d \u0026lt;tag\u0026gt;  # 删除远程tag $ git push origin :refs/tags/\u0026lt;tagName\u0026gt;  # 查看tag信息 $ git show \u0026lt;tag\u0026gt;  # 提交指定tag $ git push \u0026lt;remote\u0026gt; \u0026lt;tag\u0026gt;  # 提交所有tag $ git push \u0026lt;remote\u0026gt; --tags  # 新建一个分支，指向某个tag $ git checkout -b \u0026lt;branch\u0026gt; \u0026lt;tag\u0026gt; 查看信息 #  # 显示有变更的文件 $ git status  # 显示当前分支的版本历史 $ git log  # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat  # 搜索提交历史，根据关键词 $ git log -S \u0026lt;keyword\u0026gt;  # 显示某个commit之后的所有变动，每个commit占据一行 $ git log \u0026lt;tag\u0026gt; HEAD --pretty=format:%s  # 显示某个commit之后的所有变动，其\u0026#34;提交说明\u0026#34;必须符合搜索条件 $ git log \u0026lt;tag\u0026gt; HEAD --grep feature  # 显示某个文件的版本历史，包括文件改名 $ git log --follow \u0026lt;file\u0026gt; $ git whatchanged \u0026lt;file\u0026gt;  # 显示指定文件相关的每一次diff $ git log -p \u0026lt;file\u0026gt;  # 显示过去5次提交 $ git log -5 --pretty --oneline  # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn  # 显示指定文件是什么人在什么时间修改过 $ git blame \u0026lt;file\u0026gt;  # 显示暂存区和工作区的差异 $ git diff  # 显示暂存区和上一个commit的差异 $ git diff --cached \u0026lt;file\u0026gt;  # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD  # 显示两次提交之间的差异 $ git diff \u0026lt;first-branch\u0026gt;...\u0026lt;second-branch\u0026gt;  # 显示今天你写了多少行代码 $ git diff --shortstat \u0026#34;@{0 day ago}\u0026#34;  # 显示某次提交的元数据和内容变化 $ git show \u0026lt;commit\u0026gt;  # 显示某次提交发生变化的文件 $ git show --name-only \u0026lt;commit\u0026gt;  # 显示某次提交时，某个文件的内容 $ git show \u0026lt;commit\u0026gt;:\u0026lt;filename\u0026gt;  # 显示当前分支的最近几次提交 $ git reflog 远程同步 #  # 下载远程仓库的所有变动 $ git fetch \u0026lt;remote\u0026gt;  # 显示所有远程仓库 $ git remote -v  # 显示某个远程仓库的信息 $ git remote show \u0026lt;remote\u0026gt;  # 增加一个新的远程仓库，并命名 $ git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt;  # 取回远程仓库的变化，并与本地分支合并 $ git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;  # 上传本地指定分支到远程仓库 $ git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;  # 强行推送当前分支到远程仓库，即使有冲突 $ git push \u0026lt;remote\u0026gt; --force  # 推送所有分支到远程仓库 $ git push \u0026lt;remote\u0026gt; --all 撤销 #  # 恢复暂存区的指定文件到工作区 $ git checkout \u0026lt;file\u0026gt;  # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout \u0026lt;commit\u0026gt; \u0026lt;file\u0026gt;  # 恢复暂存区的所有文件到工作区 $ git checkout .  # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset \u0026lt;file\u0026gt;  # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard  # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset \u0026lt;commit\u0026gt;  # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard \u0026lt;commit\u0026gt;  # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep \u0026lt;commit\u0026gt;  # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert \u0026lt;commit\u0026gt;  # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop "},{"id":5,"href":"/SE-Labs/docs/labs/lab02/frontend_index/","title":"前端实验指南","section":"Lab02 前后端基础Ⅰ","content":"Lab02 前端基础 #  实验目的 #   了解基础的HTML，CSS，JS语法 练习引入css、js代码 练习处理事件 练习修改页面样式 练习修改页面逻辑 练习使用浏览器控制台 回顾第1次实验课git的使用  资源链接 #  https://bhpan.buaa.edu.cn:443/link/2B8C3DF0CE32D21908D8007C843940A5\n有效期限：2022-08-01 23:59\n实验指南 #   查看资源链接中的前端入门基础.mp4、前端入门基础.pdf 完成实验作业并于 3.27 日晚 12 点前提交至 软院云平台  实验作业 #  你可以在所给资源的homework文件夹中找到实验文档并填写\n任务1 #  资源中的homework文件夹给出了一个模仿百度主页的网页（index.html），可是这个网页缺少了 CSS 和 JS 文件，你需要把附件文件夹中的 CSS 和 JS 代码引入到网页中\n完成该环节的之后的网页截图\n任务2 #  修改 index.js，使得点击搜索按钮后，浏览器会弹窗显示所搜索的内容。但是当搜索框为空的时候，点击搜索按钮后，浏览器会弹窗显示“请输入搜索内容”\n搜索框为空的截图\n点击后的截图\n搜索框有内容的截图\n再次点击后的截图\n任务3 #  修改index.html，使热榜部分其尽可能与下方相似（温馨提示，请不要偷懒直接插一张截图进去，我们会看代码的），相关的图片放在了img文件下，其中把“《你的学号》”换成你真实的学号（例如20370000），如有必要可以注释原有的代码，但不要删除，因为后续的任务还会用到\n 修改完的网页截图\n任务4 #  修改 index.js，使得在点击 ID 为 top-right 的元素之后，会调用 clickLogin 函数\n点击前的截图\n点击后的截图\n任务5 #  点击登录按钮后，似乎用户已经正确地登录，但是页面似乎发生了一些错误。请尝试修改 initUserInfo 函数，使得用户登录后，页面显示依然正常。（使用审查元素分析网页变化）\n点击后审查页面变化截图\n修复后登录截图\n任务6 #  将你的代码提交至远程仓库，github或者gitee均可（至少保留1周），并在实验文档中说明\n附加任务（非强制） #  这部分建议学有余力的同学看一看，可能需要你额外学习一些前端知识\n  在任务2 的基础上，使用户在搜索框按下回车的时候也可以进行搜索，并且会跳转到百度对应的搜索页面（处理键盘事件，链接外部页面）\n  在任务3的基础上加上醒目的大图，尽可能与下图相似（处理相对位置，没有思路可以去百度榜单F12看看他是怎么写的）\n 里面最显眼的那张图片并不是一个正方形哦，是一个圆角矩形，而且你可以发现我们所提供的原图是没有左上角的1标志，请思考如何引入    实验报告 #  填写homework中的实验文档，简要阐明你的思路\n提交方式 #    截止时间：2022/3/27 晚12点\n  提交方式： 软院云平台\n  提交内容：完善后的实验文档，将其命名为：\n学号_姓名_第2次实验.docx/pdf   "},{"id":6,"href":"/SE-Labs/docs/labs/lab03/frontend_index/","title":"前端实验指南","section":"Lab03 前后端基础Ⅱ","content":"Lab03 前端基础 #  实验目的 #   了解 Vue 框架的基本使用 熟悉 Vue CLI 的基础命令 掌握 Vue-Router、Vuex 与 Vue 的集成 掌握 ElementUI 的基础使用 掌握使用 Axios 发送网络请求的方法 熟悉 Vue 单页面组件的使用  资源链接 #  https://bhpan.buaa.edu.cn:443/link/2B8C3DF0CE32D21908D8007C843940A5\n有效期限：2022-08-01 23:59\n实验指南 #   查看资源链接中Vue和CSS相关的内容 完成实验作业并于 4.3 日晚 12 点前提交至 软院云平台  实验作业 #  根据作业.pdf中的作业要求完成作业，并将文档和演示视频打包提交到云平台上。\n任务 1 #  使用 Vue CLI 创建一个自己的 Vue 项目，项目至少包含 Vue-Router 和 Vuex，其他依赖项可以自行决定要不要添加。\n任务 2 #  在 views 中新建一个单页面组件，将其命名为Login.vue。注册路径为/login的路由(修改router/index.js)，并将Login.vue挂载到该路由下。在首页加入该页面的入口(如下图所示)。\n router/index.js 的代码截图\n任务 3 #  在 store/index.js 中注册名为 isLogin 的状态(初始为 false 即未登录)，用于判断用户是否登录。对该状态增加两个 mutation，名为 login 和 logout，分别用于登录和登出。\nstore/index.js 的代码截图\n任务 4 #  在 Home 页面使用条件渲染，如果登录则显示下面状态 1，否则显示状态 2。在状态 2 时，点击上下的 login 都应该可以跳转。\n状态1 状态2  Home 组件的代码截图\n任务 5 #  Login 组件中的按钮应该使用 ElementUI 的按钮，在未登录时显示状态 1，在登录时显示状态 2。\n登录按钮和未登录按钮展示需要使用 v-if 条件渲染，两者各绑定一个事件，分别对应触发 vuex 的 mutation（login 和 logout）。  状态1 状态2  Login 组件的代码截图\n实验报告 #  按照要求完成实验文档和演示视频，可以简要阐明你的思路\n提交方式 #    截止时间：2022/4/3 晚 12 点\n  提交方式： 软院云平台\n  提交内容：打包后的实验文档和演示视频，将其命名为：\n学号_姓名_第3次实验.zip   "},{"id":7,"href":"/SE-Labs/docs/labs/lab02/Example-code/","title":"前端示例代码","section":"Lab02 前后端基础Ⅰ","content":"HTML 入门 #  HTML 使用元素来描述页面 #  \u0026lt;html\u0026gt;  \u0026lt;body\u0026gt;  \u0026lt;h1\u0026gt;This is a title. \u0026lt;/h1\u0026gt;  \u0026lt;p\u0026gt;这是 p 标签，用于包裹一个段落的内容。\u0026lt;/p\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 标签的特性（属性） #  \u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; 常用的标签（1） body head #  \u0026lt;html\u0026gt;  \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;  \u0026lt;h1\u0026gt;Hello HTML!\u0026lt;/h1\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 常用的标签（2） h1 - h6 #  \u0026lt;html\u0026gt;  \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;  \u0026lt;h1\u0026gt;Hello HTML!\u0026lt;/h1\u0026gt;  \u0026lt;h2\u0026gt;Hello HTML!\u0026lt;/h2\u0026gt;  \u0026lt;h3\u0026gt;Hello HTML!\u0026lt;/h3\u0026gt;  \u0026lt;h4\u0026gt;Hello HTML!\u0026lt;/h4\u0026gt;  \u0026lt;h5\u0026gt;Hello HTML!\u0026lt;/h5\u0026gt;  \u0026lt;h6\u0026gt;Hello HTML!\u0026lt;/h6\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 常用的标签（3） ol ul li #  \u0026lt;ol\u0026gt;  \u0026lt;li\u0026gt;有序列表项目1\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;有序列表项目2\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;有序列表项目3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;  \u0026lt;ul\u0026gt;  \u0026lt;li\u0026gt;无序列表项目1\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;无序列表项目2\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;无序列表项目3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 常用的标签（4） #  \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34;\u0026gt;点击打开百度\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;https://7n.w3cschool.cn/statics/images/logonew2.png\u0026#34; /\u0026gt; 常用的标签（5） table tr th td #  \u0026lt;table\u0026gt;  \u0026lt;tr\u0026gt;  \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;  \u0026lt;th\u0026gt;星期六\u0026lt;/th\u0026gt; \t\u0026lt;th\u0026gt;星期日\u0026lt;/th\u0026gt;  \u0026lt;/tr\u0026gt;  \u0026lt;tr\u0026gt;  \u0026lt;th\u0026gt;门票售出量\u0026lt;/th\u0026gt;  \u0026lt;td\u0026gt;120\u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt;135\u0026lt;/td\u0026gt;  \u0026lt;/tr\u0026gt;  \u0026lt;tr\u0026gt;  \u0026lt;th\u0026gt;销售额\u0026lt;/th\u0026gt;  \u0026lt;td\u0026gt;$600\u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt;$675\u0026lt;/td\u0026gt;  \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 常用的标签（6） input textarea #  \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;提示词\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; value=\u0026#34;value\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; \u0026lt;textarea\u0026gt;\u0026lt;/textarea\u0026gt; 常用的标签（7） select option form #  \u0026lt;select\u0026gt;  \u0026lt;option value=\u0026#34;0\u0026#34;\u0026gt;请选择内容\u0026lt;/option\u0026gt;  \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;第一个选项\u0026lt;/option\u0026gt;  \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;第二个选项\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 注释 #  \u0026lt;!-- 注释的内容 --\u0026gt; CSS 介绍 #  CSS 简介 #  p {  color: #565656; } 在 HTML 中引入 CSS 样式 #  \u0026lt;html\u0026gt;  \u0026lt;head\u0026gt;  \u0026lt;link href=\u0026#34;css/style.css\u0026#34; type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt;  \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; body, a{  overflow-x: overlay;  padding: 0 !important; }  .hide_scroll{  overflow: hidden !important; } 在 HTML 中引入 CSS 样式 #  \u0026lt;html\u0026gt;  \u0026lt;head\u0026gt;  \u0026lt;style\u0026gt;  body, a {  padding: 0;  }  \u0026lt;/style\u0026gt;  \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;a style=\u0026#34;text-decoration: none;\u0026#34;\u0026gt;example\u0026lt;/a\u0026gt; JavaScript 基础与 DOM #  JavaScript 毒瘤：== #  \u0026#39;\u0026#39; == \u0026#39;0\u0026#39; // false 0 == \u0026#39;\u0026#39; // true 0 == \u0026#39;0\u0026#39; // true  false == \u0026#39;false\u0026#39; // false false == 0 // true null == undefined // true  \u0026#39;\\n\u0026#39; == 0 // true \u0026#39;\\t\u0026#39; == 0 // true \u0026#39;\\r\\n\u0026#39; == 0 // true  0.1 + 0.2 == 0.3 // false JavaScript 对象、函数 #  var object = {  name: \u0026#39;JavaScript\u0026#39;,  age: 15,  \u0026#39;like JavaScript\u0026#39;: true }; object.name;  object[\u0026#39;like JavaScript\u0026#39;];  object.sex;\t// undefined function add(a, b) {  return a + b; }  var add = function(a, b) {  return a + b; };  add(0, 1); function(a, b) {  return a + b; } var object = {  func1: function() {  ...  },   func2() {  ...  } }; JavaScript 数组 #  var arr = [1, \u0026#39;JavaScript\u0026#39;, {}];  var arr = new Array(10); arr[1]; arr.push(0.6); arr.indexOf(1); arr.sort(function(a, b) {  return a – b; }); arr = arr.concat([2, 3]); arr.length; 函数调用模式与 this 变量（1） #  var object = {  age: 18,  func: function() {  this.age;  } };  object.func(); 函数调用模式与 this 变量（2） #  var func = function() {  this; };  func(); 函数调用模式与 this 变量（3） #  var func = function(params) {  this.age; };  var object = {  age: 18, };  func.apply(object, 1); JavaScript 毒瘤 2：this 变量的设计 #  function gloFunction(f) {  var age = 17;  f(); }  var object = {  age: 18,  func: function() {  gloFunction(function() {  console.log(this.age);  });  } };  object.func(); func: function() {  var that = this;  gloFunction(function() {  console.log(that.age);  }); } 将 JavaScript 引入 HTML #  \u0026lt;html\u0026gt;  \u0026lt;head\u0026gt;  \u0026lt;script src=\u0026#34;js/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;html\u0026gt;  \u0026lt;head\u0026gt;  \u0026lt;script\u0026gt; \t// ...  \u0026lt;/script\u0026gt;  \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML DOM #  \u0026lt;a  id=\u0026#34;openBaidu\u0026#34;  class=\u0026#34;link-a\u0026#34;  href=\u0026#34;http://www.baidu.com\u0026#34;\u0026gt;  点击打开百度 \u0026lt;/a\u0026gt; var a = document.createElement(\u0026#39;a\u0026#39;); a.id = \u0026#39;openBaidu\u0026#39;; a.classList.add(\u0026#39;link-a\u0026#39;); a.setAttribute(\u0026#39;href\u0026#39;, \u0026#39;http://www.baidu.com\u0026#39;); a.innerHTML = \u0026#39;点击打开百度\u0026#39;; parentNode.appendChild(a); parentNode.getElementById(\u0026#39;openBaidu\u0026#39;); parentNode.getElementsByTagName(\u0026#39;a\u0026#39;); parentNode.getElementsByClassName(\u0026#39;link-a\u0026#39;);  document.getElementsByClassName(\u0026#39;link-a\u0026#39;); innerHTML 的使用 #  \u0026lt;ul id=\u0026#34;nav\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; document.getElementById(\u0026#39;nav\u0026#39;).innerHTML = \u0026#39;\u0026lt;li\u0026gt;index\u0026lt;/li\u0026gt;\u0026#39;;  document.getElementById(\u0026#39;nav\u0026#39;).textContent = \u0026#39;\u0026lt;li\u0026gt;index\u0026lt;/li\u0026gt;\u0026#39;; 设置监听器 #  document.getElementById(\u0026#39;openBaidu\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function(){  // ... });  document.getElementById(\u0026#39;openBaidu\u0026#39;).removeEventListener(\u0026#39;click\u0026#39;, myFunction); DOM 加载与 JavaScript 执行时机 #  \u0026lt;script\u0026gt;  document.getElementById(\u0026#39;mid\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;mid\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt;  window.onload = function() {  document.getElementById(\u0026#39;mid\u0026#39;);  }; \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;mid\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; alert 与 console #  alert(\u0026#39;这是一个提示\u0026#39;);  console.log(\u0026#39;控制台信息\u0026#39;); console.warn(\u0026#39;控制台信息\u0026#39;); console.error(\u0026#39;控制台信息\u0026#39;); "},{"id":8,"href":"/SE-Labs/docs/labs/lab03/backend_index/","title":"后端实验指南","section":"Lab03 前后端基础Ⅱ","content":"Lab03 后端进阶 #  紧急加播 #  考虑到大家java才刚学没多久，因此酌情调整难度，已经完成的同学可以提交老版本的作业，但是在实验报告中需要注明，新接触的同学按照最新的实验指南和要求即可\n实验目的 #    学习使用maven管理配置依赖\n  了解springboot的基础知识，能够自行创建一个springboot项目\n  了解基础的分层结构\n  锻炼解决问题的能力，通过查询官方文档或其他技术博客解决遇到的问题\n  资源链接 #  https://bhpan.buaa.edu.cn:443/link/2B8C3DF0CE32D21908D8007C843940A5 有效期限：2022-08-01 23:59\n实验指南 #   阅读资源中提供的Maven资料，了解Maven的基础内容，如果你还不了解基础的java依赖引入，可以先行学习，再来学习Maven 学习《Springboot基础》与视频资料，自行创建一个基础的Springboot项目并成功运行 学习使用postman（可参考官网教程https://learning.postman.com/docs/getting-started/introduction， 不推荐一口气读完，推荐随用随查）  实验作业 #  任务1 #  提供视频中的基础代码(跟视频手打or自己弄明白原理手搓)，并连接自己的本地数据库（需要回忆你的数据库课程知识），并且成功运行，请提供运行截图\n任务2（考虑到大多数同学都是初学java，本任务不再强行要求） #  根据注册代码和 session 的处理方式完成登录请求（localhost:8090/login），并使用Postman 测试，请提供运行截图\n~~ 温馨提示：session 的处理方式 ppt 上所说的是绝对不够用的，这里是为了考验大家能不能通过官网等渠道获取到有用信息 ~~  \n任务3 #  增加个人信息查询功能（localhost:8090/show_info），并使用 Postman 测试（在 body 中返回“name”：“xxx”， “password”： “xxx”），请提供运行截图\n写一份实验报告，简要说明任务 1 的完成过程，以及在任务 2 和任务 3 中使用 Postman 测试情况截图（测试数据和结果），最好附上你的心得\n注：完成上述需求并且运行无 bug 和报错即满分。  提交方式 #   截止时间：2022/4/3 晚12点 提交方式：软院云平台 提交内容：实现上述任务1和3功能后的项目代码文件夹，和实验报告，命名格式如下：  学号_姓名_第3次实验.zip |-- 项目代码文件夹  -- 学号_姓名_第3次实验_实验报告.docx/pdf "},{"id":9,"href":"/SE-Labs/docs/labs/lab03/yaml%E5%B0%8F%E6%8C%87%E5%8D%97/","title":"yaml小指南","section":"Lab03 前后端基础Ⅱ","content":"YAML是一个类似 XML、JSON 的标记性语言。它强调以数据为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称\u0026quot;一种人性化的数据格式语言\u0026quot;。\n\u0026lt;heima\u0026gt; \u0026lt;age\u0026gt;15\u0026lt;/age\u0026gt; \u0026lt;address\u0026gt;Beijing\u0026lt;/address\u0026gt; \u0026lt;/heima\u0026gt; heima: age: 15 address: Beijing YAML的语法比较简单，主要有下面几个：\n 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格( 低版本限制 ) 缩进的空格数不重要，只要相同层级的元素左对齐即可 \u0026lsquo;#\u0026lsquo;表示注释  YAML支持以下几种数据类型：\n 纯量：单个的、不可再分的值 对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）  # 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期 # 1 布尔类型 c1: true (或者True) # 2 整型 c2: 234 # 3 浮点型 c3: 3.14 # 4 null类型 c4: ~ # 使用~表示null # 5 日期类型 c5: 2018-02-17 # 日期必须使用ISO 8601格式，即yyyy-MM-dd # 6 时间类型 c6: 2018-02-17T15:02:31+08:00 # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 # 7 字符串类型 c7: heima # 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 c8: line1 line2 # 字符串过多的情况可以拆成多行，每一行会被转化成一个空格 # 对象 # 形式一(推荐): heima: age: 15 address: Beijing # 形式二(了解): heima: {age: 15,address: Beijing} # 数组 # 形式一(推荐): address: - 顺义 - 昌平 # 形式二(了解): address: [顺义,昌平]  小提示：\n1 书写yaml切记: 后面要加一个空格\n2 如果需要将多段yaml配置放在一个文件中，中间要使用---分隔\n3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确\n https://www.json2yaml.com/convert-yaml-to-json\n "},{"id":10,"href":"/SE-Labs/docs/labs/lab02/backend_index/","title":"后端实验指南","section":"Lab02 前后端基础Ⅰ","content":"Lab02 后端基础 #  实验目的 #   掌握 Python 基础代码 了解 Django 框架，学习使用框架编写几个简单 API 学习使用 Postman 请求工具测试后端 API  资源链接 #  https://bhpan.buaa.edu.cn:443/link/2B8C3DF0CE32D21908D8007C843940A5\nValid Until: 2022-08-01 23:59\n实验指南 #   观看上述云盘链接中 Lab02/后端Django 目录下的视频教程 文字教程可查阅 Django入门教程 和 Django入土教程 完成实验作业并于 3.27 日晚 12 点前提交至 软院云平台  实验作业 #  本次作业在提供的模板项目代码上修改完成，也可以自己新建项目，体验 Django 初始化项目的过程。\n任务一 完善注册 #  请完善注册的API，实现以下功能：\n 增加用户名格式检测，保证用户名由英文或数字组成：当请求用户名含其它字符时，返回 errno 为 1003，msg 为 用户名不合法； 增加用户名检测，保证用户名不重复：当数据库里存在请求携带的用户名时，返回 errno 为 1004，msg 为 用户名已存在； 增加密码检测，保证密码由8~18位字符组成，且需同时包含英文和数字：当密码不合法时，返回 errno 为 1005，msg 为 密码不合法。  注册API返回信息汇总：\n   情况 errno msg     成功 0 注册成功   请求方式不为POST 1001 请求方式错误   两次输入的密码不同 1002 两次输入的密码不同   用户名含除英文和数字以外的字符 1003 用户名不合法   用户名重复 1004 用户名已存在   密码不符合规则 1005 密码不合法    返回样例：\n{  \u0026#34;errno\u0026#34;: 0,  \u0026#34;msg\u0026#34;: \u0026#34;注册成功\u0026#34; } 任务二 新增“文章”表项 #  每次更改数据库模型都需要重新生成迁移文件 makemigrations \u0026amp; migrate  添加新的数据库表项——文章，用于存放用户发表的文章，其属性至少包含标题、描述信息、文章内容、创建时间、文章状态（包含审核中、已发布、审核失败），并能够体现与用户的关联关系（外键）。\n任务三 新增“发布文章”API #  实现“发布文章”的API，满足用户发布文章的需求。\n请严谨考虑发布文章的业务逻辑，包含用户登录信息验证、请求字段能否为空、用户发布文章后文章应处于哪一状态等，同时需规定好返回的错误码 errno 和描述信息 msg。\n任务四 新增“查看文章列表”API #  实现“查看文章列表”的API，满足：用户想查看自己处于某个状态的所有文章，该API能返回相应状态的文章列表。\n返回的文章列表中，每个文章对象应包含：标题、描述信息、创建时间。\n响应示例（可参考不强制）：\n{  \u0026#34;errno\u0026#34;: 0,  \u0026#34;msg\u0026#34;: \u0026#34;查询成功\u0026#34;,  \u0026#34;data\u0026#34;: [  {  \u0026#34;title\u0026#34;: \u0026#34;软件工程实用教程\u0026#34;,  \u0026#34;description\u0026#34;: \u0026#34;北航软件工程基础课程参考教材\u0026#34;,  \u0026#34;create_time\u0026#34;: \u0026#34;2022/3/25 15:32\u0026#34;  },  {  \u0026#34;title\u0026#34;: \u0026#34;计算机科学引论\u0026#34;,  \u0026#34;description\u0026#34;: \u0026#34;北航计算机导论课程参考教材\u0026#34;,  \u0026#34;create_time\u0026#34;: \u0026#34;2022/3/25 16:32\u0026#34;  }  ] } 任务五 聪明的你帮助教改改Bug（不强制） #  背景：Zewan助教看到群里有人说要把“相信你”改为“相信聪明的你”，便用VScode打开网站项目。正要添上“聪明的”这三个字，突然瞥到之前在 Django入门教程写的登录处理函数有点奇怪，便仔细端详了一下。果不其然，发现了bug。\n任务：Super2021 聪明的你，请思考一下处理登录请求的完整逻辑，肉眼帮助教找出 publish/views.py 中登录函数 login 的 Bug，并修改。\n 突发奇想加个任务，一定不是我懒得改了\n 任务六 实验文档报告（不做要求） #  如果你仍感叹于后端之大，也沉醉于Web情话，可以在实验报告中唠一唠你的实现思路。当然如果你选择无感，也可以不写。\n提交方式 #   截止时间：2022/3/27 晚12点 提交方式：软院云平台 提交内容：实现上述任务功能后的项目代码文件夹，和实验报告（如果有的话），命名格式如下：  学号_姓名_第2次实验.zip |-- 项目代码文件夹 `-- 学号_姓名_第2次实验_实验报告.docx/pdf（如果有的话） 完成本次后端作业后，相信聪明的你已经有能力开心地投入到大作业后端的开发中了~~\n"},{"id":11,"href":"/SE-Labs/docs/labs/lab02/django_door/","title":"Django入门篇","section":"Lab02 前后端基础Ⅰ","content":"Django 入门篇 #  后端的主要功能是，管理数据库、响应前端的请求。例如用户登录，前端需要携带用户名和密码等信息向后端某个路由发送请求，后端则根据用户名查找数据库，验证密码是否正确，并携带结果响应前端。  Django 是一个由 Python 编写的高级 Web 框架，使用框架进行 Web 开发，能避免重复造轮子，而专注于应用程序的业务逻辑。\n环境配置 #  相比于直接安装 Python 某个版本，更推荐安装 Anaconda 管理虚拟环境。Python 项目的版本和依赖各有千秋，而使用 Anaconda 能针对项目建立虚拟环境，互不干扰且便于管理。\nAnaconda下载地址：\n 官网：https://www.anaconda.com/ 清华镜像：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/（选择最新版本即可）  安装步骤中注意勾选添加至环境变量中  安装 Anaconda 后，使用 conda 指令新建一个虚拟环境，用于开发 Django 项目：\nconda create --name django python=3.8 # 虚拟环境名为django，python版本指定3.8 进入 django 虚拟环境：\nconda activate django Conda常用指令 conda info --env # 查看所有虚拟环境 conda create --name \u0026lt;name\u0026gt; python=\u0026lt;version\u0026gt; # 新建环境 conda activate \u0026lt;name\u0026gt; # 进入虚拟环境 conda deactivate # 退出环境    安装 django 依赖：\npip install django 当然，如果你不安装 Anaconda，也可以直接通过上面最后一条指令安装 django 依赖。\n新建项目 #  命令行创建 在某个文件夹内打开终端，输入下面指令创建 Django 项目：\ndjango-admin startproject press # 新建名为 press（出版社）的项目 创建成功后，出现了 press 文件夹，在目录下可以看到 press 文件夹和 manage.py 文件，其内容主要是项目运行入口和总配置，接下来我们先创建一个 app（应用程序），用于实现业务逻辑，包含数据库模型的建立、建立路由和API响应前端的请求。\npython manage.py startapp publish # 新建名为 publish 的 app 创建 app 成功后，目录下多出一个文件夹名为 publish，包含 views、models 等文件。先不管项目内容，输入以下命令，让项目跑起来：\npython manage.py runserver 运行成功后，将提示运行在 http://127.0.0.1:8000/，浏览器打开即可。\nPycharm创建 用Pycharm新建项目十分方便，省去了命令行操作，点击导航栏文件处，选择新建项目。\n如下图，如果已新建好 Conda 虚拟环境，请配置已有环境。此处我还选择了新建名为 publish 的 app，将在该 app 中实现业务逻辑，包含数据库模型的建立、建立路由和API响应前端的请求。\n 新建成功后，点击右上角运行按钮。运行成功后，将提示运行在 http://127.0.0.1:8000/，浏览器打开即可。\n 了解项目结构 #  经过上述步骤，我们创建了 django 项目，在新建了名为 publish 的 app。\n目录结构如下：\npress |-- publish # app目录 | |-- __init__.py # python包声明 | |-- admin.py | |-- apps.py # app配置文件 | |-- models.py # 数据库模型配置 | |-- tests.py # 测试模块 | `-- views.py # 视图编写文件（API-实现业务逻辑，响应前端的请求） |-- press | |-- __init__.py | |-- asgi.py | |-- settings.py # 项目配置文件 | |-- urls.py # 后端路由设置 | `-- wsgi.py # uwsgi运行入口 |-- manage.py # django命令行工具 `-- db.sqlite3 # 数据库文件 看到这里有可能有点模糊，拎几个重点的需要修改的文件出来介绍：\n publish/models.py：数据库模型设置，在这里要建立数据库表项及其属性 publish/views.py：编写api的文件，在这里要编写和规划所有的请求处理函数。 press/settings.py：项目总配置文件，在这里实现跨域设置、app信息等 press/urls.py：后端路由设置，在这里指定后端API的路由，以供前端发送请求  项目预设置 #  添加 APP 信息 #  若是在 Pycharm 中创建的项目，在 press/settings.py 中已自动添加好 app 信息，无需再度添加；如果是命令行创建，则需在 settings 文件的 INSTALLED_APPS 中添加 app 名字：\nINSTALLED_APPS = [  \u0026#39;django.contrib.admin\u0026#39;,  \u0026#39;django.contrib.auth\u0026#39;,  \u0026#39;django.contrib.contenttypes\u0026#39;,  \u0026#39;django.contrib.sessions\u0026#39;,  \u0026#39;django.contrib.messages\u0026#39;,  \u0026#39;django.contrib.staticfiles\u0026#39;,  \u0026#39;publish\u0026#39;, # app name ] 在这里添加 app 的名字，是为了告诉 django 这个 python 包是这个项目的一个 app。\n路由分发 #  一个较大的项目可能需要建立多个app，在其中实现业务逻辑，这样不同 app 全部 api 的路由都在一个文件中（press/urls.py）添加是不合适的。因此，可以在各 app 下新建 urls.py 文件，并在总的路由文件中指定包含这些文件。具体操作请看下面：\n首先，在 app（publish目录） 下新建 urls.py 文件，内容如下：\n# publish/urls.py from django.urls import path from .views import *  urlpatterns = [  # path(\u0026#39;url_name\u0026#39;, api_name)  # 这是一个样例，指定路由名为url_name，对应处理函数为当前app内views.py中的api_name ] 接着在项目配置目录（press目录）的 urls.py 引入上面文件的路由：\n# press/urls.py from django.contrib import admin from django.urls import path, include  urlpatterns = [  path(\u0026#39;api/admin/\u0026#39;, admin.site.urls),  path(\u0026#39;api/publish/\u0026#39;, include((\u0026#39;publish.urls\u0026#39;, \u0026#39;publish\u0026#39;))),  # 将各app（如publish）中指定的路由导入到总路由中 ] 上述操作实现了将 publish 这个 app 指定的 urls，全部接到了路由 api/publish/ 之后。\n示例 出版网站 #  假设要开发一个出版网站，最基本的是给作者提供注册、登录和退出登录这三个功能。\n 假设作者的用户名唯一，可作为用户标识\n 逻辑：\n 当前端发来注册请求时，后端验证两次密码是否一致，成功后将信息填入到数据库中； 当前端发来登录请求时，后端需要拿着用户名到数据库中查询，验证密码是否正确，再返回给前端信息；若登录成功还需存储登录信息； 当前端发来退出登录请求时，后端需要清空登录信息，并返回结果。  数据库模型 #  完成上述逻辑前，我们需要先修改 publish/models.py，添加 author 用户的表项。\n# publish/models.py from django.db import models  class Author(models.Model):  # Author表项，含用户名和密码，均为字符串属性，并设置最大长度  username = models.CharField(max_length=100)  password = models.CharField(max_length=20) 在修改数据库模型之后，一定要生成迁移文件，并应用新的数据库模型。在终端输入以下命令实现：\npython manage.py makemigrations # 生成迁移文件 python manage.py migrate # 迁移数据库模型  输入上述命令迁移后运行，可以发现在项目根目录出现了 db.sqlite3 文件。这是一个数据库文件，如何可视化请见后面 sqlite 数据库可视化，你也可以先看可视化部分再回头。\n 数据库模型指令介绍 Django 的 Model 数据类型 #     数据类型 说明     AutoField 根据 ID 自增长的 IntegerField 字段，通常用于主键ID   IntegerField 32位整数，可自定义选项   BooleanField 布尔值(True/False)字段   CharField 字符串字段，对小字符串和大字符串都适用；对于大量文本建议使用TextField。必须参数：max_length（字段的最大字符数）   DateField 利用 Python 的 datetime.date 实例来表示日期   DateTimeField 利用 datetime.datetime 实例表示日期和时间   EmailField 带有 email 合法性检测的CharField，默认max_length=75   TextField 超大文本字段   FileField 文件字段   ImageField 继承于FileField，确保是有效图片    Model 数据类型的通用参数 #     参数 说明     null 是否允许为空值，默认为false   default 该属性的默认值   primary_key 该属性是否为主键，默认为false   unique 该属性的值是否唯一，默认为false    时间类型的可选参数 #   DateField.auto_now：设为 True 时，每一次保存对象时，Django 都会自动将该字段的值设置为当前时间。一般用来表示最后修改时间。 DateField.auto_now_add：设为 True 时，第一次创建对象时，Django 自动将该字段的值设置为当前时间，一般用来表示对象创建时间。    注册功能 #  完成一个业务功能的实现，一般分为两步：编写业务逻辑处理函数，指定路由。\n先实现业务逻辑，在 publish/views.py 中编写 API 函数，内容如下：\n# publish/views.py from django.http import JsonResponse from django.views.decorators.csrf import csrf_exempt from publish.models import Author # 引入数据库 Author 对象  @csrf_exempt # 跨域设置 def register(request): # 继承请求类  if request.method == \u0026#39;POST\u0026#39;: # 判断请求方式是否为 POST（此处要求为POST方式）  username = request.POST.get(\u0026#39;username\u0026#39;) # 获取请求体中的请求数据  password_1 = request.POST.get(\u0026#39;password_1\u0026#39;)  password_2 = request.POST.get(\u0026#39;password_2\u0026#39;)  if password_1 != password_2: # 若两次输入的密码不同，则返回错误码errno和描述信息msg  return JsonResponse({\u0026#39;errno\u0026#39;: 1002, \u0026#39;msg\u0026#39;: \u0026#34;两次输入的密码不同\u0026#34;})  else:  # 新建 Author 对象，赋值用户名和密码并保存  new_author = Author(username=username, password=password_1)  new_author.save() # 一定要save才能保存到数据库中  return JsonResponse({\u0026#39;errno\u0026#39;: 0, \u0026#39;msg\u0026#39;: \u0026#34;注册成功\u0026#34;})  else:  return JsonResponse({\u0026#39;errno\u0026#39;: 1001, \u0026#39;msg\u0026#39;: \u0026#34;请求方式错误\u0026#34;}) HTTP八大请求详情可见 HTTP八大请求，常用GET和POST。\n GET：用于获取资源，请求中不应该包含数据体。 POST：用于提交数据，数据被包含在请求体中，处理该请求服务器可能会建立或更新资源。   Django数据库存取操作 增 #  # 方法一 user = User() user.name = \u0026#34;ZewanHuang\u0026#34; user.save() # 方法二 user = User(id=1, name=\u0026#34;ZewanHuang\u0026#34;) user.save() # 方法三 User.objects.create(id=1, name=\u0026#34;ZewanHuang\u0026#34;) 查 #  # 查询特定结果 user = User.objects.get(id=1) # 查看多个结果（返回一个列表） users = User.objects.filter(kind=‘学生’) # 查询全部结果 users = User.objects.all() 改 #  # 方法一：查后改后保存 user = User.objects.get(id=1) user.name = \u0026#34;Zewan\u0026#34; user.save() # 方法二：更新 users = User.objects.filter(kind=\u0026#34;学生\u0026#34;) users.update(kind=\u0026#34;老师\u0026#34;) 删 #  user = User.objects.get(id=1) user.delete()    接下来为该 API 指定路由，在 publish/urls.py 中添加：\n# publish/urls.py from django.urls import path from .views import *  urlpatterns = [  path(\u0026#39;register\u0026#39;, register), # 指定register函数的路由为register ] 由于前面做了路由的 include 设置，因此该 register 对应的路由为 api/publish/register，若项目运行在 8000 端口，则完整的路由为 http://127.0.0.1:8000/api/publish/register。\n这样实现后，该 API 详细信息为：\n 路由：http://127.0.0.1:8000/api/publish/register 请求数据：用户名 username，密码 password_1，确认密码 password_2 响应数据：JSON格式，错误码 errno 和描述信息 msg 响应样例： {  \u0026#34;errno\u0026#34;: 0,  \u0026#34;msg\u0026#34;: \u0026#34;注册成功\u0026#34; }    如何测试API在后面 Postman测试中介绍，你也可以先看测试部分再回头\n 登录功能 #  理解注册API后，登录也是一样的套路。\n请求处理函数：\n# publish/views.py @csrf_exempt def login(request):  if request.method == \u0026#39;POST\u0026#39;:  username = request.POST.get(\u0026#39;username\u0026#39;) # 获取请求数据  password = request.POST.get(\u0026#39;password\u0026#39;)  author = Author.objects.get(username=username)  if author.password == password: # 判断请求的密码是否与数据库存储的密码相同  # 密码正确则将用户名存储于session（django用于存储登录信息的数据库位置）  request.session[\u0026#39;username\u0026#39;] = username  return JsonResponse({\u0026#39;errno\u0026#39;: 0, \u0026#39;msg\u0026#39;: \u0026#34;登录成功\u0026#34;})  else:  return JsonResponse({\u0026#39;errno\u0026#39;: 1002, \u0026#39;msg\u0026#39;: \u0026#34;密码错误\u0026#34;})  else:  return JsonResponse({\u0026#39;errno\u0026#39;: 1001, \u0026#39;msg\u0026#39;: \u0026#34;请求方式错误\u0026#34;}) Django session 存储登录信息 session：临时保存在服务器端的用户数据，本质是键值对。将用户登录时的ID（标志）存储在 session 中以便后续获取，当处理修改用户信息等请求时，从中获取并核验身份，防止用户能修改其它用户的信息\n登录时：\n# 如果登录成功，存储用户标志信息 if user.password == password:  request.session[\u0026#39;id\u0026#39;] = user.id \trequest.session[\u0026#39;kind\u0026#39;] = \u0026#34;user\u0026#34; 检查登录信息时，需要获取 session 存储的数据：\nusername = request.POST.get(\u0026#39;username\u0026#39;) if request.session.get(\u0026#39;username\u0026#39;) == username:  # 若session存储数据和请求的用户名相同，则登录信息核验成功  # 防止用户能修改其它用户的信息    添加路由：\n# publish/urls.py urlpatterns = [  path(\u0026#39;register\u0026#39;, register), # 指定register函数的路由为register  path(\u0026#39;login\u0026#39;, login) ] 退出登录功能 #  处理函数：\n@csrf_exempt def logout(request):  request.session.flush()  return JsonResponse({\u0026#39;errno\u0026#39;: 0, \u0026#39;msg\u0026#39;: \u0026#34;注销成功\u0026#34;}) 指定路由：\nurlpatterns = [  path(\u0026#39;register\u0026#39;, register), # 指定register函数的路由为register  path(\u0026#39;login\u0026#39;, login),  path(\u0026#39;logout\u0026#39;, logout) ] sqlite 数据库可视化 #  这里只展示 Pycharm 如何可视化 db.sqlite3 文件。\n在 Pycharm 右侧侧边栏处，点击 Database 按钮，添加 Data Source：\n 在弹出的选项框中，选择项目根目录的 sqlite3 文件；若提示缺失驱动，点击下载并测试连接，成功后点击确认即可：\n 若未显示数据库，请按下图操作：\n Postman 测试 #  前后端分离开发中，仅后端一般无法通过点击图形化界面进行测试，后端的测试也不应该依赖于前端，而应该独立进行。因此后端的测试，需要借助工具模拟前端请求，向后端相应的路由发送请求，并查看响应数据。\nPostman 就是这样的工具。\nPostman 下载地址：https://www.postman.com/\n注册账号，下载后登录 Postman，点击客户端左上角 Workspaces 组件，可为你的项目创建一个工作区，如果你对保存请求信息不感冒，使用默认 My Workspace 也可以。Postman 仅仅是测试的工具，因此这里也不多介绍管理文件夹存储请求记录这些东西了。\n下面示例测试注册接口：\n 可以看到返回数据是 JSON 格式，且提示注册成功。\n简单的调试方法 #  对后端来说，如果使用 Postman 发送请求后结果和预料的正常结果不一致，但这时候我们只知道哪个函数出错了，难以缩小 bug 的范围并找出原因。\n这里提供一个非常简单的小技巧，可以在 Python 出错的函数中，加上一些 print 输出，然后用 Postman 再次发请求，你可以在跑后端的终端中查看到你 print 的信息。\n举个非常简单的例子，现在我查询文章列表出 bug 了，我想判断有没有进入循环，就可以在 for 循环内加入 print(1)，然后用 Postman 再发一次请求，就能在跑后端的终端中看是否有 1 输出，没有则未进入循环。（万能的 print 法找 bug）\n"},{"id":12,"href":"/SE-Labs/docs/labs/lab02/django_earth/","title":"Django入土篇","section":"Lab02 前后端基础Ⅰ","content":"Django 入土篇 #  Django 从入门到入土 #  Liujiang Blog：https://www.liujiangblog.com/course/django/84\nGet Liujiang Blog  Marvolo Djangobook：https://super-buaa-2021.github.io/Djangobook/\nGet Djangobook  Django 指令或代码指示 #  项目指令 #  django-admin startproject \u0026lt;project_name\u0026gt; # 创建项目 python manage.py startapp \u0026lt;app_name\u0026gt; # 创建APP python manage.py runserver # 本地运行 python manage.py makemigrations # 生成迁移文件 python manage.py migrate # 迁移数据库模型 Django Models #  Django 的 Model 数据类型 #     数据类型 说明     AutoField 根据 ID 自增长的 IntegerField 字段，通常用于主键ID   IntegerField 32位整数，可自定义选项   BooleanField 布尔值(True/False)字段   CharField 字符串字段，对小字符串和大字符串都适用；对于大量文本建议使用TextField。必须参数：max_length（字段的最大字符数）   DateField 利用 Python 的 datetime.date 实例来表示日期   DateTimeField 利用 datetime.datetime 实例表示日期和时间   EmailField 带有 email 合法性检测的CharField，默认max_length=75   TextField 超大文本字段   FileField 文件字段   ImageField 继承于FileField，确保是有效图片    Model 数据类型的通用参数 #     参数 说明     null 是否允许为空值，默认为false   default 该属性的默认值   primary_key 该属性是否为主键，默认为false   unique 该属性的值是否唯一，默认为false    时间类型的可选参数 #   DateField.auto_now：设为 True 时，每一次保存对象时，Django 都会自动将该字段的值设置为当前时间。一般用来表示最后修改时间。 DateField.auto_now_add：设为 True 时，第一次创建对象时，Django 自动将该字段的值设置为当前时间，一般用来表示对象创建时间。  Django 数据库增删查改 #  增 #  # 方法一 user = User() user.name = \u0026#34;ZewanHuang\u0026#34; user.save() # 方法二 user = User(id=1, name=\u0026#34;ZewanHuang\u0026#34;) user.save() # 方法三 User.objects.create(id=1, name=\u0026#34;ZewanHuang\u0026#34;) 查 #  # 查询特定结果 user = User.objects.get(id=1) # 查看多个结果（返回一个列表） users = User.objects.filter(kind=‘学生’) # 查询全部结果 users = User.objects.all() 改 #  # 方法一：查后改后保存 user = User.objects.get(id=1) user.name = \u0026#34;Zewan\u0026#34; user.save() # 方法二：更新 users = User.objects.filter(kind=\u0026#34;学生\u0026#34;) users.update(kind=\u0026#34;老师\u0026#34;) 删 #  user = User.objects.get(id=1) user.delete() Django session 登录信息 #  session：临时保存在服务器端的用户数据，本质是键值对。将用户登录时的ID（标志）存储在 session 中以便后续获取，当处理修改用户信息等请求时，从中获取并核验身份，防止用户能修改其它用户的信息\n登录时：\n# 如果登录成功，存储用户标志信息 if user.password == password:  request.session[\u0026#39;id\u0026#39;] = user.id \trequest.session[\u0026#39;kind\u0026#39;] = \u0026#34;user\u0026#34; 检查登录信息时，需要获取 session 存储的数据：\nusername = request.POST.get(\u0026#39;username\u0026#39;) if request.session.get(\u0026#39;username\u0026#39;) == username:  # 若session存储数据和请求的用户名相同，则登录信息核验成功  # 防止用户能修改其它用户的信息 "},{"id":13,"href":"/SE-Labs/docs/labs/lab01/","title":"Lab01 Git","section":"Labs","content":"Lab01 Git #  实验目的 #   了解分布式版本控制系统的概念 掌握 Git 的基本指令 实践团队如何使用 Git 进行合作开发 实践分支合并时冲突的解决  资源链接 #  https://bhpan.buaa.edu.cn:443/link/2B8C3DF0CE32D21908D8007C843940A5\nValid Until: 2022-08-01 23:59\n实验指南 #   观看上述云盘链接中 Lab01 的视频 文字教程可查阅 Git简易教程 和 Git指令全集 完成实验作业并于 3.20 日晚 12 点前提交至 软院云平台  实验作业 #  远程仓库可选 Gitee 或 Github；操作过程中请保存好截图，根据后面所讲的提交方式打包提交。  任务一 个人作业 #    远程仓库上新建代码仓库（private），仓库名：Platform-学号。\n在仓库主页截图\n  远程仓库上以 master/main 分支为基础，新建 dev 分支，添加 index.html 文件。（master/main 分支存储生产环境，dev 分支存储开发环境）\n在dev分支主页截图\n  clone 远程仓库到本地，创建本地 dev 分支与远程同步。（此处结果应为在本地 dev 分支看到 index.html 文件）\n在控制台和本地目录截图\n  在本地修改 index.html 文件（内容如下），上传本地改动到远程仓库。\n控制台命令、仓库主页查看 index.html 截图 index.html 文件修改内容 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;北航软件工程基础\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Lab01 任务一\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Lab01 任务一\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;      在远程修改 index.html 文件（内容如下），本地同步远程改动。\n本地查看 index.html 内容截图 index.html 文件修改内容 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;北航软件工程基础\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Lab01 任务一\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Lab01 任务一\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;      在本地合并 dev 分支到 master/main 分支，提交本地改动到远程仓库，并在远程 master/main 查看 index.html 内容。（以上结果是本地和远程的 master、dev 分支都可以看到 index.html 的最新改动）\n在网页 master/main 分支查看 index.html 内容并截图\n  任务二 小组作业 #  请保留任务二所创建的仓库一周；\n任务二小组共同完成一份文档，文档模板见所给云盘资源 Lab01。\n 初始创建与同步 #    组长在远程仓库上新建 public 代码仓库，仓库名：Study-组号，并为组员授权。\n仓库主页截图、仓库授权用户截图\n  远程仓库上以 master/main 分支为基础，创建 dev 分支，添加 main.py 文件。\n  各小组成员 clone 远程仓库到本地，创建本地 dev 分支与远程同步。\n  合并分支练习 #   组长在远程仓库以 dev 分支为基础，为各个组员（包括自己）创建 exercise-学号 分支，各组员创建本地 exercise-学号 分支，同步远程代码仓库，在本地 exercise-学号 分支添加 function_学号.py 文件（各组员在自己的分支修改），上传本地改动至远程仓库。\n各组员本地 Git 命令行截图和远程仓库各分支文件内容截图\nfunction_学号.py 文件修改内容 print('My student_id: 学号')      各组员在本地将 exercise-学号 合并到 dev 分支。\n  上传到远程仓库 dev 分支。\n远程仓库 dev 分支截图\n  合并分支冲突 #   各组员同步远程 dev 分支更新，确保此时内容为最新内容。\n  各组员修改本地 exercise-学号 分支的 main.py 文件。\nmain.py 文件修改内容 import os os.system('python function_学号.py')      各组员在本地将 exercise-学号 分支合并到 dev 分支。\n各组员 Git 命令截图\n  等所有组员结束上一步骤后，先组长再组员依次上传到远程 dev 分支，冲突时一律保留组长的修改。（解决冲突执行 commit 时注明信息为 conflict solved）\n各组员 Git 命令截图和处理冲突截图\n  执行第10步骤时，当其他人 push 后你无法直接 push（当然你可以先尝试 push 看有无警告），需要 pull 同步他人修改后才能 push，而此时 pull 下来后你就会发现有冲突了  完成发布 #   待第10步骤完成后，组长在本地同步仓库 dev 分支，合并到 master/main 分支，并上传到远程 master/main 分支。\n组长 Git 命令截图和仓库主页 master/main 分支的 main.py 文件内容\n  提交方式 #   截止时间：2022/3/20 晚12点 提交方式：软院云平台 提交内容：两个 word 文档或 pdf 文档，放在压缩包内，命名格式如下  学号_姓名_第1次实验.zip |-- 学号_姓名_第1次实验_任务1.docx/pdf `-- 学号_姓名_第1次实验_任务2.docx/pdf 注意事项 #   文档中必须包括各步骤说明以及相关截图。 commit 时要求说清楚更改的内容。 任务二小组共同完成一份文档，组长和组员都需提交，文档模板见所给云盘资源 Lab01。   "},{"id":14,"href":"/SE-Labs/docs/labs/lab02/","title":"Lab02 前后端基础Ⅰ","section":"Labs","content":"Lab02 前后端基础 #  本次实验内容为前后端基础，每位同学只需要完成前端或后端的作业内容，并提交相应的作业。\n建议优先按照组内前后端分工，学习相应的方面，乐此不疲者欢迎全栈！\n建议组内三位负责前端，两位负责后端。  传送门 #   前端： 前端 HTML/CSS/JS 后端： 后端 Django 框架  前后端简介 #  前后端不分离 #  通过浏览器访问网站链接时，后端提前渲染好页面，一般以模板为基础动态生成，返回给浏览器。\n特点：前后端内容耦合到一起\n 前后端分离 #  前端负责页面显示，浏览器访问时，前端返回静态页面，后通过 JS 方法向后端发送请求、接收响应。\n负责工作：\n 前端：与浏览器联系，负责渲染页面内容，跳转路由，存取浏览器缓存，与后端交互 后端：负责存取数据库信息，处理复杂数据，响应前端的请求（后端不需要关心页面）   "},{"id":15,"href":"/SE-Labs/docs/labs/lab03/","title":"Lab03 前后端基础Ⅱ","section":"Labs","content":"Lab03 前后端基础 #  本次实验内容为前后端基础，每位同学只需要完成前端或后端的作业内容，并提交相应的作业。\n建议优先按照组内前后端分工，学习相应的方面，乐此不疲者欢迎全栈！\n建议组内三位负责前端，两位负责后端。  传送门 #   前端： 前端 Vue 框架 后端： 后端 SpringBoot 框架  "},{"id":16,"href":"/SE-Labs/docs/labs/lab04/","title":"Lab04 项目管理与数据库建模","section":"Labs","content":"Lab04 项目管理与数据库建模 #  "},{"id":17,"href":"/SE-Labs/docs/labs/lab05/","title":"Lab05 UML图的绘制","section":"Labs","content":"Lab05 UML图的绘制 #  "},{"id":18,"href":"/SE-Labs/docs/labs/lab06/","title":"Lab06 软件测试","section":"Labs","content":"Lab06 软件测试 #  "},{"id":19,"href":"/SE-Labs/docs/labs/lab07/","title":"Lab07 项目部署","section":"Labs","content":"Lab07 项目部署 #  "},{"id":20,"href":"/SE-Labs/docs/labs/lab03/vuebook/","title":"VueBook","section":"Lab03 前后端基础Ⅱ","content":"VueBook #   VueBook 是 Zewan 助教在假期认真编写的 Vue2 教程 如果觉得北航云盘的资料不够充足，可以继续学习 VueBook 中的内容 VueBook 的链接为：https://super-buaa-2021.github.io/Vuebook/ Vue2 的文档在这里：https://cn.vuejs.org/v2/guide/  打开VueBook  "}]